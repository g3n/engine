<?xml version="1.0" encoding="US-ASCII" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>

<rfc number="5215" category="std">

<front>
<title abbrev="Vorbis RTP Payload Format">RTP Payload Format for Vorbis Encoded Audio</title>

<author initials="L" surname="Barbato" fullname="Luca Barbato">
<organization abbrev="Xiph">Xiph.Org Foundation</organization>
<address>
<email>lu_zero@gentoo.org</email>
<uri>http://xiph.org/</uri>
</address>
</author>

<date month="August" year="2008" />

<area>General</area>
<workgroup>AVT Working Group</workgroup>
<keyword>I-D</keyword>

<keyword>Internet-Draft</keyword>
<keyword>Vorbis</keyword>
<keyword>RTP</keyword>

<keyword>example</keyword>

<abstract>

<t>
This document describes an RTP payload format for transporting Vorbis encoded
audio. It details the RTP encapsulation mechanism for raw Vorbis data and 
the delivery mechanisms for the decoder probability model (referred to
as a codebook), as well as other setup information.
</t>

<t>
Also included within this memo are media type registrations and the details
necessary for the use of Vorbis with the Session Description Protocol (SDP).
</t>

</abstract>

</front>

<middle>

<section anchor="Introduction" title="Introduction">

<t>
Vorbis is a general purpose perceptual audio codec intended to allow 
maximum encoder flexibility, thus allowing it to scale competitively 
over an exceptionally wide range of bit rates. At the high 
quality/bitrate end of the scale (CD or DAT rate stereo, 16/24 bits), it 
is in the same league as MPEG-4 AAC.
Vorbis is also intended for lower and higher sample rates (from 
8kHz telephony to 192kHz digital masters) and a range of channel 
representations (monaural, polyphonic, stereo, quadraphonic, 5.1, 
ambisonic, or up to 255 discrete channels).
</t>

<t>
Vorbis encoded audio is generally encapsulated within an Ogg format bitstream
<xref target="RFC3533"></xref>, which provides framing and synchronization.
For the purposes of RTP transport, this layer is unnecessary, and so raw Vorbis
packets are used in the payload.
</t>

<section anchor="Terminology" title="Conformance and Document Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14, <xref target="RFC2119"/> and indicate requirement levels for compliant implementations.  Requirements apply to all implementations unless otherwise stated.</t>
<t>An implementation is a software module that supports one of the media types defined in this document.  Software modules may support multiple media types, but conformance is considered individually for each type.</t>
<t>Implementations that fail to satisfy one or more "MUST" requirements are considered non-compliant.  Implementations that satisfy all "MUST" requirements, but fail to satisfy one or more "SHOULD" requirements, are said to be "conditionally compliant".  All other implementations are "unconditionally compliant".</t>

</section>
</section>

<section anchor="Payload Format" title="Payload Format">

<t>
For RTP-based transport of Vorbis-encoded audio, the standard RTP header is
followed by a 4-octet payload header, and then the payload data. The payload
headers are used to associate the Vorbis data with its associated decoding
codebooks as well as indicate if the following packet contains fragmented
Vorbis data and/or the number of whole Vorbis data frames. The payload data
contains the raw Vorbis bitstream information. There are 3 types of Vorbis
data; an RTP payload MUST contain just one of them at a time.
</t>

<section anchor="RTP Header" title="RTP Header">

<t>
The format of the RTP header is specified in <xref target="RFC3550"></xref>
and shown in <xref target="RTP Header Figure"/>.  This payload format
uses the fields of the header in a manner consistent with that specification.
</t>

<t>
<figure anchor="RTP Header Figure" title="RTP Header">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>
</t>

<t>
The RTP header begins with an octet of fields (V, P, X, and CC) to support
specialized RTP uses (see <xref target="RFC3550"></xref> and 
<xref target="RFC3551"></xref> for details). For Vorbis RTP, the following
values are used.
</t>

<t>
Version (V): 2 bits</t>
<t>
This field identifies the version of RTP. The version used by this
specification is two (2).
</t>

<t>
Padding (P): 1 bit</t>
<t>
Padding MAY be used with this payload format according to Section 5.1 of
<xref target="RFC3550"></xref>.
</t>

<t>
Extension (X): 1 bit</t>
<t>
The Extension bit is used in accordance with <xref target="RFC3550"></xref>.
</t>

<t>
CSRC count (CC): 4 bits</t>
<t>
The CSRC count is used in accordance with <xref target="RFC3550"></xref>.
</t>

<t>
Marker (M): 1 bit</t>
<t>
Set to zero.  Audio silence suppression is not used.  This conforms to Section 4.1
of <xref target="VORBIS-SPEC-REF"></xref>.
</t>

<t>
Payload Type (PT): 7 bits</t>
<t>
An RTP profile for a class of applications is expected to assign a payload type
for this format, or a dynamically allocated payload type SHOULD be chosen that
designates the payload as Vorbis.
</t>

<t>
Sequence number: 16 bits</t>
<t>
The sequence number increments by one for each RTP data packet sent, and may be
used by the receiver to detect packet loss and to restore the packet sequence. This
field is detailed further in <xref target="RFC3550"></xref>.
</t>

<t>
Timestamp: 32 bits</t>
<t>
A timestamp representing the sampling time of the first sample of the first
Vorbis packet in the RTP payload. The clock frequency MUST be set to the sample
rate of the encoded audio data and is conveyed out-of-band (e.g., as an SDP parameter).
</t>

<t>
SSRC/CSRC identifiers: </t>
<t>
These two fields, 32 bits each with one SSRC field and a maximum of 16 CSRC
fields, are as defined in <xref target="RFC3550">
</xref>.  
</t>

</section>

<section anchor="Payload Header" title="Payload Header">

<t>
The 4 octets following the RTP Header section are the Payload Header. This
header is split into a number of bit fields detailing the format of the
following payload data packets.
</t>

<figure anchor="Payload Header Figure" title="Payload Header">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Ident                     | F |VDT|# pkts.|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
Ident: 24 bits</t>
<t>
This 24-bit field is used to associate the Vorbis data to a decoding
Configuration. It is stored as a network byte order integer.
</t>

<t>
Fragment type (F): 2 bits</t>
<t>
This field is set according to the following list:
</t>
<vspace blankLines="1" />
<list style="empty">
<t>      0 = Not Fragmented</t>
<t>      1 = Start Fragment</t>
<t>      2 = Continuation Fragment</t>
<t>      3 = End Fragment</t>
</list>

<t>
Vorbis Data Type (VDT): 2 bits</t>
<t>
This field specifies the kind of Vorbis data stored in this RTP packet. There
are currently three different types of Vorbis payloads. Each packet MUST contain only a single type of Vorbis packet (e.g., you must not aggregate configuration and comment packets in the same RTP payload).
</t>

<vspace blankLines="1" />
<list style="empty">
<t>      0 = Raw Vorbis payload</t>
<t>      1 = Vorbis Packed Configuration payload</t>
<t>      2 = Legacy Vorbis Comment payload</t>
<t>      3 = Reserved</t>
</list>

<t> The packets with a VDT of value 3 MUST be ignored.</t>

<t>
The last 4 bits represent the number of complete packets in this payload. This
provides for a maximum number of 15 Vorbis packets in the payload. If the
payload contains fragmented data, the number of packets MUST be set to 0.
</t>

</section>

<section anchor="Payload Data" title="Payload Data">

<t>
Raw Vorbis packets are currently unbounded in length; application profiles will
likely define a practical limit. Typical Vorbis packet sizes range from very
small (2-3 bytes) to quite large (8-12 kilobytes). The reference implementation
<xref target="LIBVORBIS"></xref> typically produces packets less than ~800
bytes, except for the setup header packets, which are ~4-12 kilobytes. Within an
RTP context, to avoid fragmentation, the Vorbis data packet size SHOULD be kept
sufficiently small so that after adding the RTP and payload headers, the
complete RTP packet is smaller than the path MTU.
</t>

<figure anchor="Payload Data Figure" title="Payload Data Header">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            length             |       vorbis packet data     ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
Each Vorbis payload packet starts with a two octet length header, which is used
to represent the size in bytes of the following data payload, and is followed by the
raw Vorbis data padded to the nearest byte boundary, as explained by the <xref target="VORBIS-SPEC-REF">Vorbis I Specification</xref>. The length value is stored
as a network byte order integer.
</t>

<t>
For payloads that consist of multiple Vorbis packets, the payload data consists
of the packet length followed by the packet data for each of the Vorbis packets
in the payload.
</t>

<t>
The Vorbis packet length header is the length of the Vorbis data block only and
does not include the length field.
</t>

<t>
The payload packing of the Vorbis data packets MUST follow the guidelines
set out in <xref target="RFC3551"></xref>, where the oldest Vorbis packet occurs
immediately after the RTP packet header. Subsequent Vorbis packets, if any, MUST
follow in temporal order.
</t>

<t>
Audio channel mapping is in accordance with the
<xref target="VORBIS-SPEC-REF">Vorbis I Specification</xref>.
</t>

</section>

<section anchor="Example RTP Packet" title="Example RTP Packet">

<t>
Here is an example RTP payload containing two Vorbis packets.
</t>

<figure anchor="Example Raw Vorbis Packet" title="Example Raw Vorbis Packet">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 2 |0|0|  0    |0|      PT     |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               timestamp (in sample rate units)                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronisation source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Ident                     | 0 | 0 | 2 pks |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            length             |          vorbis data         ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        vorbis data                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            length             |   next vorbis packet data    ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        vorbis data                          ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..               vorbis data                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
The payload data section of the RTP packet begins with the 24-bit Ident field
followed by the one octet bit field header, which has the number of Vorbis
frames set to 2.  Each of the Vorbis data frames is prefixed by the two octets
length field. The Packet Type and Fragment Type are set to 0. The Configuration
that will be used to decode the packets is the one indexed by the ident value.
</t>

</section>
</section>



<section anchor="Configuration Headers" title="Configuration Headers">

<t>
Unlike other mainstream audio codecs, Vorbis has no statically 
configured probability model. Instead, it packs all entropy decoding 
configuration, Vector Quantization and Huffman models into a data block
that must be transmitted to the decoder with the compressed data.
A decoder also requires information detailing the number of audio 
channels, bitrates, and similar information to configure itself for a 
particular compressed data stream. These two blocks of information are 
often referred to collectively as the "codebooks" for a Vorbis stream,
and are included as special "header" packets at the start 
of the compressed data. In addition,
the <xref target="VORBIS-SPEC-REF">Vorbis I specification</xref>
requires the presence of a comment header packet that gives simple
metadata about the stream, but this information is not required for 
decoding the frame sequence.
</t>

<t>
Thus, these two codebook header packets must be received by the decoder before
any audio data can be interpreted. These requirements pose problems in RTP,
which is often used over unreliable transports.
</t>

<t>
Since this information must be transmitted reliably and, as the RTP 
stream may change certain configuration data mid-session, there are 
different methods for delivering this configuration data to a 
client, both in-band and out-of-band, which are detailed below.
In order to set up an initial state for the client application, the
configuration MUST be conveyed via the signalling channel used to set up
the session. One example of such signalling is
<xref target="RFC4566">SDP</xref> with the
<xref target="RFC3264">Offer/Answer Model</xref>.
Changes to the configuration MAY be communicated via a re-invite,
conveying a new SDP, or sent in-band in the RTP channel.
Implementations MUST support an in-band delivery of updated codebooks,
and SHOULD support out-of-band codebook update using a new SDP file.
The changes may be due to different codebooks as well as 
different bitrates of the RTP stream.
</t>

<t>For non-chained streams, the recommended Configuration delivery
method is inside the <xref target="Packed Configuration">Packed
Configuration</xref> in the SDP as explained the <xref
target="Mapping Media Type Parameters into SDP"> Mapping Media Type
Parameters into SDP</xref>.
</t>

<t>
The 24-bit Ident field is used to map which Configuration will be used to
decode a packet. When the Ident field changes, it indicates that a change in
the stream has taken place. The client application MUST have in advance the
correct configuration. If the client detects a change in the Ident value and
does not have this information, it MUST NOT decode the raw associated Vorbis
data until it fetches the correct Configuration.
</t>

<section anchor="In-band Header Transmission" title="In-band Header Transmission">

<t>
The <xref target="Packed Configuration">Packed Configuration</xref> Payload is
sent in-band with the packet type bits set to match the Vorbis Data Type.
Clients MUST be capable of dealing with fragmentation and periodic
<xref target="RFC4588">re-transmission of</xref> the configuration headers.
The RTP timestamp value MUST reflect the transmission time of the first data packet for which this configuration applies.
</t>

<section anchor="Packed Configuration" title="Packed Configuration">

<t>
A Vorbis Packed Configuration is indicated with the Vorbis Data Type field set
to 1. Of the three headers defined in the
<xref target="VORBIS-SPEC-REF">Vorbis I specification</xref>, the
Identification and the Setup MUST be packed as they are, while the Comment
header MAY be replaced with a dummy one.</t>
<t>
The packed configuration stores Xiph codec
configurations in a generic way: the first field stores the number of the following packets
minus one (count field), the next ones represent the size of the headers
(length fields), and the headers immediately follow the list of length fields.
The size of the last header is implicit.</t>
<t>
The count and the length fields are encoded using the following logic: the data
is in network byte order; every byte has the most significant bit used
as a flag, and the following 7 bits are used to store the value.
The first 7 most significant bits are stored in the first byte.
If there are remaining bits, the flag bit is set to 1 and the subsequent
7 bits are stored in the following byte.
If there are remaining bits, set the flag to 1 and the same procedure is
repeated.
The ending byte has the flag bit set to 0. To decode, simply iterate
over the bytes until the flag bit is set to 0. For every byte, the data
is added to the accumulated value multiplied by 128.</t>
<t>
The headers are packed in the same order as they are present in Ogg <xref target="VORBIS-SPEC-REF" />:
Identification, Comment, Setup.</t>

<t>
The 2 byte length tag defines the length of the packed headers as the sum of
the Configuration, Comment, and Setup lengths.</t>

<figure anchor="Packed Configuration Figure" title="Packed Configuration Figure">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |             xxxx              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             xxxxx                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Ident                    | 0 | 1 |      1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           length              | n. of headers |    length1    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    length2    |                  Identification              ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        Identification                       ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        Identification                       ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        Identification                       ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..               Identification                 |    Comment   ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                            Comment                          ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                            Comment                          ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                            Comment                          ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..           Comment            |             Setup            ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                            Setup                            ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                            Setup                            ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>The Ident field is set with the value that will be used by the Raw Payload
Packets to address this Configuration. The Fragment type is set to 0 because the
packet bears the full Packed configuration. The number of the packet is set to 1.</t>
</section>
</section>

<section anchor="Out of Band Transmission" title="Out of Band Transmission">

<t>
The following packet definition MUST be used when Configuration is inside
in the SDP.
</t>

<section anchor="Packed Headers" title="Packed Headers"> 

<t>
As mentioned above, the RECOMMENDED delivery vector for Vorbis configuration
data is via a retrieval method that can be performed using a reliable transport
protocol. As the RTP headers are not required for this method of delivery, the
structure of the configuration data is slightly different. The packed header
starts with a 32-bit (network-byte ordered) count field, which details
the number of packed headers that are contained in the bundle. The
following shows the Packed header
payload for each chained Vorbis stream.
</t>

<figure anchor="Packed Headers Overview Figure" title="Packed Headers Overview">
<artwork><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Number of packed headers                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Packed header                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Packed header                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<figure anchor="Packed Headers Detail Figure" title="Packed Headers Detail">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Ident                       |    length    ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..              | n. of headers |    length1    |    length2   ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..              |             Identification Header            ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .................................................................
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..              |         Comment Header                       ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .................................................................
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        Comment Header                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Setup Header                        ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .................................................................
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                         Setup Header                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>
<t>
The key difference between the in-band format and this one is that there is no
need for the payload header octet. In this figure, the comment has a size bigger
than 127 bytes.
</t>
</section>

</section>

<section anchor="Loss of Configuration Headers" title="Loss of Configuration Headers">

<t>
Unlike the loss of raw Vorbis payload data, loss of a configuration header
leads to a situation where it will not be possible to successfully decode the
stream. Implementations MAY try to recover from an error by requesting again the
missing Configuration or, if the delivery method is in-band, by buffering the
payloads waiting for the Configuration needed to decode them.
The baseline reaction SHOULD either be reset or end the RTP session.
</t>

</section>

</section>

<section anchor="Comment Headers" title="Comment Headers">

<t>
Vorbis Data Type flag set to 2 indicates that the packet contains
the comment metadata, such as artist name, track title, and so on. These
metadata messages are not intended to be fully descriptive but rather to offer basic
track/song information. Clients MAY ignore it completely. The details on the
format of the comments can be found in the <xref target="VORBIS-SPEC-REF">Vorbis I Specification</xref>.
</t>
<figure anchor="Comment Packet Figure" title="Comment Packet">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |             xxxx              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             xxxxx                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Ident                    | 0 | 2 |      1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            length             |            Comment           ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                           Comment                           ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                           Comment                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
The 2-byte length field is necessary since this packet could be fragmented.
</t>

</section>
<section anchor="Frame Packetization" title="Frame Packetization">

<t>
Each RTP payload contains either one Vorbis packet fragment or an integer
number of complete Vorbis packets (up to a maximum of 15 packets, since the
number of packets is defined by a 4-bit value).
</t>

<t>
Any Vorbis data packet that is less than path MTU SHOULD be bundled in the RTP
payload with as many Vorbis packets as will fit, up to a maximum of 15, except
when such bundling would exceed an application's desired transmission latency.
Path MTU is detailed in <xref target="RFC1191"></xref> and <xref target="RFC1981"></xref>.
</t>

<t>
A fragmented packet has a zero in the last four bits of the payload header.
The first fragment will set the Fragment type to 1. Each fragment after the
first will set the Fragment type to 2 in the payload header. The consecutive
fragments MUST be sent without any other payload being sent between the first
and the last fragment. The RTP payload containing the last fragment of the
Vorbis packet will have the Fragment type set to 3. To maintain the correct
sequence for fragmented packet reception, the timestamp field of fragmented
packets MUST be the same as the first packet sent, with the sequence number
incremented as normal for the subsequent RTP payloads; this will affect the
RTCP jitter measurement. The length field shows the fragment length.
</t>

<section anchor="Example Fragmented Vorbis Packet" title="Example Fragmented Vorbis Packet">

<t>
Here is an example of a fragmented Vorbis packet split over three RTP payloads.
Each of them contains the standard RTP headers as well as the 4-octet Vorbis
headers.
</t>

<figure anchor="Example Fragmented Packet (Packet 1)" title="Example Fragmented Packet (Packet 1)">
<artwork><![CDATA[
   Packet 1:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |           1000                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            12345                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Ident                   | 1 | 0 |      0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             length            |            vorbis data       ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        vorbis data                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
In this payload, the initial sequence number is 1000 and the timestamp is 12345.  The Fragment type is set to 1, the number of packets field is set to 0, and as
the payload is raw Vorbis data, the VDT field is set to 0.
</t>

<figure anchor="Example Fragmented Packet (Packet 2)" title="Example Fragmented Packet (Packet 2)">
<artwork><![CDATA[
   Packet 2:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |           1001                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             12345                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Ident                   | 2 | 0 |      0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             length            |          vorbis data         ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        vorbis data                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
The Fragment type field is set to 2, and the number of packets field is set to 0.
For large Vorbis fragments, there can be several of these types of payloads.
The maximum packet size SHOULD be no greater than the path MTU,
including all RTP and payload headers. The sequence number has been incremented
by one, but the timestamp field remains the same as the initial payload.
</t>

<figure anchor="Example Fragmented Packet (Packet 3)" title="Example Fragmented Packet (Packet 3)">
<artwork><![CDATA[
   Packet 3:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |           1002                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             12345                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Ident                    | 3 | 0 |      0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             length            |          vorbis data         ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ..                        vorbis data                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

<t>
This is the last Vorbis fragment payload.  The Fragment type is set to 3 and the
packet count remains set to 0. As in the previous payloads, the timestamp remains
set to the first payload timestamp in the sequence and the sequence number has
been incremented.
</t>
</section>

<section anchor="Packet Loss" title="Packet Loss">

<t>
As there is no error correction within the Vorbis stream, packet loss will
result in a loss of signal. Packet loss is more of an issue for fragmented
Vorbis packets as the client will have to cope with the handling of the
Fragment Type. In case of loss of fragments, the client MUST discard all the
remaining Vorbis fragments and decode the incomplete packet. If we use the
fragmented Vorbis packet example above and the first RTP payload is lost, the
client MUST detect that the next RTP payload has the packet count field set
to 0 and the Fragment type 2 and MUST drop it.
The next RTP payload, which is the final fragmented packet, MUST be dropped
in the same manner.
If the missing RTP payload is the last, the two fragments received will be
kept and the incomplete Vorbis packet decoded.
</t>

<t>
Loss of any of the Configuration fragment will result in the loss of the full
Configuration packet with the result detailed in the <xref target="Loss of Configuration Headers">Loss of Configuration Headers</xref> section.
</t>

</section>
</section>
<section anchor="IANA Considerations" title="IANA Considerations"> 

<list style="hanging">
<t hangText="Type name:"> audio </t>

<t hangText="Subtype name:"> vorbis </t>

<t hangText="Required parameters:">

<list style="hanging">
<t hangText="rate:"> indicates the RTP timestamp clock rate as described in <xref target="RFC3551">RTP Profile for Audio and Video Conferences with Minimal Control</xref>.
</t>

<t hangText="channels:"> indicates the number of audio channels as described in <xref target="RFC3551">RTP Profile for Audio and Video Conferences with Minimal Control</xref>.
</t>


<t hangText="configuration:"> the <xref target="RFC4648">base64</xref> representation of the <xref target="Packed Headers">Packed Headers</xref>.
</t>
</list>
</t>

<t hangText="Encoding considerations:">
<vspace blankLines="1" />
This media type is framed and contains binary data.
</t>

<t hangText="Security considerations:">
<vspace blankLines="1" />
See Section 10 of RFC 5215.</t>

<t hangText="Interoperability considerations:">
<vspace blankLines="1" />
None</t>

<t hangText="Published specification:">
<vspace blankLines="1" />
RFC 5215
<vspace blankLines="1" />
Ogg Vorbis I specification: Codec setup and packet decode.  Available from the Xiph website, http://xiph.org/
</t>


<t hangText="Applications which use this media type:">
<vspace blankLines="1"/>
Audio streaming and conferencing tools </t>

<t hangText="Additional information:">
<vspace blankLines="1" />
None </t>

<t hangText="Person &amp; email address to contact for further information:">
<vspace blankLines="1" />
Luca Barbato: &lt;lu_zero@gentoo.org&gt;<br/>
<vspace blankLines="0" />
IETF Audio/Video Transport Working Group

</t>

<t hangText="Intended usage:">
<vspace blankLines="1" />
COMMON</t>

<t hangText="Restriction on usage:">
<vspace blankLines="1" />
This media type depends on RTP framing, hence is only defined for transfer via <xref target="RFC3550">RTP</xref>.</t>

<t hangText="Author:">
<vspace blankLines="1"/>Luca Barbato</t>

<t hangText="Change controller:">
<vspace blankLines="1"/>IETF AVT Working Group delegated from the IESG</t>
</list>

<section anchor="Packed Headers IANA Considerations" title="Packed Headers IANA Considerations"> 

<t>
The following IANA considerations refers to the split configuration <xref target="Packed Headers">Packed Headers</xref> used within RFC 5215.
</t>

<list style="hanging">
<t hangText="Type name:"> audio </t>

<t hangText="Subtype name:"> vorbis-config </t>

<t hangText="Required parameters:">
<vspace blankLines="1" />
None
</t>

<t hangText="Optional parameters:">
<vspace blankLines="1" />
None
</t>

<t hangText="Encoding considerations:">
<vspace blankLines="1" />
This media type contains binary data.
</t>

<t hangText="Security considerations:">
<vspace blankLines="1" />
See Section 10 of RFC 5215.
</t>

<t hangText="Interoperability considerations:">
<vspace blankLines="1" />
None
</t>

<t hangText="Published specification:">
<vspace blankLines="1" />
RFC 5215
</t>

<t hangText="Applications which use this media type:">
<vspace blankLines="1" />
Vorbis encoded audio, configuration data
</t>

<t hangText="Additional information:"> 
<vspace blankLines="1" />
None
</t>

<t hangText="Person &amp; email address to contact for further information:">
<vspace blankLines="1" />
Luca Barbato: &lt;lu_zero@gentoo.org&gt;
<vspace blankLines="0" />
IETF Audio/Video Transport Working Group
</t>

<t hangText="Intended usage:">
COMMON
</t>

<t hangText="Restriction on usage:">
<vspace blankLines="1" />
This media type doesn't depend on the transport.
</t>

<t hangText="Author:">
<vspace blankLines="1" />
Luca Barbato</t>

<t hangText="Change controller:">
<vspace blankLines="1" />
IETF AVT Working Group delegated from the IESG</t>
</list>

</section>

</section>

<section anchor="SDP related considerations" title="SDP Related Considerations">
<t>
The following paragraphs define the mapping of the parameters described in the IANA considerations section and their usage in the <xref target="RFC3264">Offer/Answer Model</xref>. In order to be forward compatible, the implementation MUST ignore unknown parameters.
</t>

<section anchor="Mapping Media Type Parameters into SDP" title="Mapping Media Type Parameters into SDP"> 

<t>
The information carried in the Media Type specification has a
specific mapping to fields in the <xref target="RFC4566">Session Description
Protocol (SDP)</xref>, which is commonly used to describe RTP sessions.
When SDP is used to specify sessions, the mapping are as follows:
</t>

<list style="symbols">

<t>The type name ("audio") goes in SDP "m=" as the media name.</t>

<t>The subtype name ("vorbis") goes in SDP "a=rtpmap" as the encoding name.</t>

<t>The parameter "rate" also goes in "a=rtpmap" as the clock rate.</t>

<t>The parameter "channels" also goes in "a=rtpmap" as the channel count.</t>

<t>The mandated parameters "configuration" MUST be included in the SDP
"a=fmtp" attribute.</t>

</list>

<t>
If the stream comprises chained Vorbis files and all of them are known in
advance, the Configuration Packet for each file SHOULD be passed to the client
using the configuration attribute.
</t>

<t>
The port value is specified by the server application bound to the address
specified in the c= line. The channel count value specified in the rtpmap
attribute SHOULD match the current Vorbis stream or should be considered the maximum
number of channels to be expected. The timestamp clock rate MUST be a multiple
of the sample rate; a different payload number MUST be used if the clock rate
changes. The Configuration payload delivers the exact information, thus the
SDP information SHOULD be considered a hint.
An example is found below. 
</t>

<section anchor="SDP Example" title="SDP Example">
<t>The following example shows a basic SDP single stream. The first
configuration packet is inside the SDP; other configurations could be
fetched at any time from the URIs provided. The following
<xref target="RFC4648">base64</xref> configuration string is folded in this
example due to RFC line length limitations.</t>


<list style="empty">
<t>c=IN IP4 192.0.2.1</t>
<t>m=audio  RTP/AVP 98</t>
<t>a=rtpmap:98 vorbis/44100/2</t>
<t>a=fmtp:98 configuration=AAAAAZ2f4g9NAh4aAXZvcmJpcwA...;</t>
</list>
</section>

<t>
Note that the payload format (encoding) names are commonly shown in uppercase.
Media Type subtypes are commonly shown in lowercase. These names are
case-insensitive in both places.  Similarly, parameter names are
case-insensitive both in Media Type types and in the default mapping to the SDP
a=fmtp attribute. The a=fmtp line is a single line, even if it is shown as multiple lines in this document for clarity.
</t>

</section>

<section anchor="Usage with the SDP Offer/Answer Mode" title="Usage with the SDP Offer/Answer Model">

<t>
There are no negotiable parameters. All of them are declarative.
</t>

</section>

</section>
<section anchor="Congestion Control" title="Congestion Control">
<t>
The general congestion control considerations for transporting RTP
data apply to Vorbis audio over RTP as well.  See the RTP specification
<xref target="RFC3550" /> and any applicable RTP profile (e.g., <xref target="RFC3551" />).
Audio data can be encoded using a range of different bit rates, so
it is possible to adapt network bandwidth by adjusting the encoder
bit rate in real time or by having multiple copies of content encoded
 at different bit rates.
</t>
</section>
<section anchor="Example" title="Example">

<t>
The following example shows a common usage pattern that MAY be applied in
such a situation. The main scope of this section is to explain better usage
of the transmission vectors.
</t>

<section anchor="Stream Radio" title="Stream Radio">

<t>This is one of the most common situations: there is one single server streaming
content in multicast, and the clients may start a session at a random time. The
content itself could be a mix of a live stream (as the webjockey's voice)
and stored streams (as the music she plays).</t>

<t>In this situation, we don't know in advance how many codebooks we will use.
The clients can join anytime and users expect to start listening to the content
in a short time.</t>

<t>Upon joining, the client will receive the current Configuration necessary to
decode the current stream inside the SDP so that the decoding will start
immediately after.</t>

<t>When the streamed content changes, the new Configuration is sent in-band
before the actual stream, and the Configuration that has to be sent inside
the SDP is updated. Since the in-band method is unreliable, an out-of-band
fallback is provided.</t>

<t>The client may choose to fetch the Configuration from the alternate source
as soon as it discovers a Configuration packet got lost in-band, or use
<xref target="RFC3611">selective retransmission</xref> if the server supports
this feature.</t>

<t>A server-side optimization would be to keep a hash list of the
Configurations per session, which avoids packing all of them and sending the same
Configuration with different Ident tags.</t>

<t>A client-side optimization would be to keep a tag list of the Configurations
per session and not process configuration packets that are already known.</t>

</section>
</section>

<section anchor="Security Considerations" title="Security Considerations"> 
<t>
RTP packets using this payload format are subject to the security 
considerations discussed in the 
<xref target="RFC3550">RTP specification</xref>, the
<xref target="RFC4648">base64 specification</xref>, and the
<xref target="RFC3986">URI Generic syntax specification</xref>.
Among other considerations, this implies that the confidentiality of the
media stream is achieved by using encryption. Because the data compression used
with this payload format is applied end-to-end, encryption may be performed on
the compressed data.
</t>

</section> 
<section title="Copying Conditions">
  <t>The authors agree to grant third parties the irrevocable right to copy,
  use, and distribute the work, with or without modification, in any medium,
  without royalty, provided that, unless separate permission is granted,
  redistributed modified works do not contain misleading author, version,
  name of work, or endorsement information.</t>
</section>
<section anchor="Acknowledgments" title="Acknowledgments"> 

<t>
This document is a continuation of the following documents:
</t><t>
Moffitt, J., "RTP Payload Format for Vorbis Encoded Audio", February 2001.
</t><t>
Kerr, R., "RTP Payload Format for Vorbis Encoded Audio", December 2004.
</t><t>
The Media Type declaration is a continuation of the following
document:</t><t>
Short, B., "The audio/rtp-vorbis MIME Type", January 2008.
</t>

<t>
Thanks to the AVT, Vorbis Communities / Xiph.Org Foundation including Steve Casner,
Aaron Colwell, Ross Finlayson, Fluendo, Ramon Garcia, Pascal Hennequin, Ralph
Giles, Tor-Einar Jarnbjo, Colin Law, John Lazzaro, Jack Moffitt, Christopher
Montgomery, Colin Perkins, Barry Short, Mike Smith, Phil Kerr, Michael Sparks,
Magnus Westerlund, David Barrett, Silvia Pfeiffer, Stefan Ehmann, Gianni Ceccarelli and Alessandro Salvatori. Thanks to the LScube Group, in particular Federico
Ridolfo, Francesco Varano, Giampaolo Mancini, Dario Gallucci, and Juan Carlos De Martin.
</t>

</section> 

</middle>

<back>

<references title="Normative References">

<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.3550" ?>
<?rfc include="reference.RFC.3551" ?>
<?rfc include="reference.RFC.3986" ?>
<?rfc include="reference.RFC.4566" ?>
<?rfc include="reference.RFC.1191" ?>
<?rfc include="reference.RFC.1981" ?>
<?rfc include="reference.RFC.3264" ?>
<?rfc include="reference.RFC.4648" ?>

<reference anchor="VORBIS-SPEC-REF">
<front>
<title>Ogg Vorbis I specification:  Codec setup and packet decode.  Available from the Xiph website, http://xiph.org/vorbis/doc/Vorbis_I_spec.html</title>
</front>
</reference>

</references>

<references title="Informative References">

<?rfc include="reference.RFC.3533" ?>

<reference anchor="LIBVORBIS">
<front>
<title>libvorbis: Available from the dedicated website, http://vorbis.com/</title>
</front>
</reference>

<?rfc include="reference.RFC.3611" ?>
<?rfc include="reference.RFC.4588" ?>

</references>
</back>
</rfc>
